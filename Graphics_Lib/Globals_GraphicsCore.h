#ifndef GLOBALS_GRAPHICSCORE_H
#define GLOBALS_GRAPHICSCORE_H

// the 4005 warning needs to be disabled it just is a warning saying that you are using the non-windows 8 way to create a directx application. In windows 8, directx is included with visual studio
#pragma warning(push)
#pragma warning( disable : 4005 )
#include "d3d11.h"
#include "d3dx11.h"
#include "d3dcompiler.h"
#include "D3DX11tex.h"
#pragma warning(pop)
#include "Debug.h"// graphical debugging file
#include "../Utilities/Utilities.h"// general purpose utilities
#include "../Utilities/MyMath.h"

enum Filter { NEAREST, LINEAR, BILINEAR, TRILINEAR, ANISOTROPIC };
enum AddressMode {WRAP, CLAMP, BORDER};
enum BufferAccess {DEFAULT =D3D11_USAGE_DEFAULT , IMMUTABLE=D3D11_USAGE_IMMUTABLE, DYNAMIC=D3D11_USAGE_DYNAMIC , STAGING =D3D11_USAGE_STAGING};
enum MapAccess{ MAP_READ=1, MAP_WRITE, MAP_READ_WRITE, MAP_WRITE_DISCARD, MAP_WRITE_NO_OVERWRITE};
enum CpuAccess{ CPU_NONE =0, CPU_READ = D3D11_CPU_ACCESS_READ, CPU_WRITE=D3D11_CPU_ACCESS_WRITE, CPU_READ_WRITE = D3D11_CPU_ACCESS_READ | D3D11_CPU_ACCESS_WRITE };
enum BufferType { VERTEX_BUFFER = D3D11_BIND_VERTEX_BUFFER, INDEX_BUFFER =D3D11_BIND_INDEX_BUFFER, CONSTANT_BUFFER=D3D11_BIND_CONSTANT_BUFFER, SHADER_BUFFER =D3D11_BIND_SHADER_RESOURCE, 
	STREAM_BUFFER =D3D11_BIND_STREAM_OUTPUT, RENDERTARGET_BUFFER =D3D11_BIND_RENDER_TARGET , DEPTH_BUFFER =D3D11_BIND_DEPTH_STENCIL, UNORDERERD_BUFFER =D3D11_BIND_UNORDERED_ACCESS , STREAM_BUFFER_OR_VERTEX_BUFFER =  D3D11_BIND_VERTEX_BUFFER| D3D11_BIND_STREAM_OUTPUT};
enum ResourceFlags { NO_FLAG =0, GENERATE_MIPS =1, SHARED, TEXTURECUBE, DRAWINDIRECT_ARGS, BUFFER_ALLOW_RAW_VIEWS, BUFFER_STRUCTURED, RESOURCE_CLAMP, SHARED_KEYEDMUTEX, GDI_COMPATIBLE  };
enum Comparison { NEVER =1, LESS, EQUAL , LEQUAL, GREATER, NOTEQUAL, GEQUAL , ALWAYS };
enum Primitives { PRIM_POINTLIST, PRIM_LINELIST, PRIM_LINE_STRIP, PRIM_TRIANGLELIST, PRIM_TRIANGLE_STRIP, PRIM_LINELIST_ADJ	,PRIM_LINESTRIP_ADJ , PRIM_TRIANGLELIST_ADJ, PRIM_TRIANGLESTRIP_ADJ, PRIM_1_CONTROL_POINT,
	PRIM_2_CONTROL_POINT, PRIM_3_CONTROL_POINT, PRIM_4_CONTROL_POINT, PRIM_5_CONTROL_POINT, PRIM_6_CONTROL_POINT, PRIM_7_CONTROL_POINT, PRIM_8_CONTROL_POINT, PRIM_9_CONTROL_POINT, PRIM_10_CONTROL_POINT, PRIM_11_CONTROL_POINT,
	PRIM_12_CONTROL_POINT, PRIM_13_CONTROL_POINT, PRIM_14_CONTROL_POINT, PRIM_15_CONTROL_POINT, PRIM_16_CONTROL_POINT, PRIM_17_CONTROL_POINT, PRIM_18_CONTROL_POINT, PRIM_19_CONTROL_POINT, PRIM_20_CONTROL_POINT, PRIM_21_CONTROL_POINT,
	PRIM_22_CONTROL_POINT, PRIM_23_CONTROL_POINT, PRIM_24_CONTROL_POINT, PRIM_25_CONTROL_POINT, PRIM_26_CONTROL_POINT, PRIM_27_CONTROL_POINT, PRIM_28_CONTROL_POINT, PRIM_29_CONTROL_POINT, PRIM_30_CONTROL_POINT, PRIM_31_CONTROL_POINT,
	PRIM_32_CONTROL_POINT, PRIM_UNDEFINED
};



enum AttributeType {TYPE_COLOR =0, TYPE_VERTEX = 1, TYPE_TEXCOORD, TYPE_NORMAL, TYPE_TANGENT , TYPE_BINORMAL , TYPE_WEIGHT, TYPE_BONE , TYPE_BLENDINDICES , TYPE_MATRIX};
enum AttributeFormat {FORMAT_FLOAT, FORMAT_HALF_FLOAT, FORMAT_BYTE_UNORM, FORMAT_BYTE_UINT};

// Blending constants
enum Blend {ZERO=1, ONE , SRC_COLOR, INV_SRC_COLOR, SRC_ALPHA, INV_SRC_ALPHA, DEST_ALPHA, INV_DEST_ALPHA, INV_DEST_COLOR , SRC_ALPHA_SAT, BLEND_FACTOR, INV_BLEND_FACTOR, SRC1_COLOR, INV_SRC1_COLOR, SRC1_ALPHA, INV_SRC1_ALPHA };
enum Blend_Op {OP_ADD=1, OP_SUBTRACT, OP_REV_SUBTRACT, OP_MIN, OP_MAX  };


enum QUERY {EVENT, OCCLUSION,TIMESTAMP , TIMESTAMP_DISJOINT, PIPELINE_STATISTICS, OCCLUSION_PREDICATE, SO_STATISTICS, SO_OVERFLOW_PREDICATE, SO_STATISTICS_STREAM0, SO_OVERFLOW_PREDICATE_STREAM0, 
	SO_STATISTICS_STREAM1, SO_OVERFLOW_PREDICATE_STREAM1, SO_STATISTICS_STREAM2, SO_OVERFLOW_PREDICATE_STREAM2, SO_STATISTICS_STREAM3, SO_OVERFLOW_PREDICATE_STREAM3 };

// Stencil-test constants
enum DepthStencil_Op { KEEP =1, OP_ZERO, REPLACE, INCR_SAT, DECR_SAT, INVERT, INCR};

enum Cull_Mode { CULL_NONE =1, CULL_FRONT, CULL_BACK };
enum Fill_Mode { WIREFRAME =2, SOLID };

const D3D11_PRIMITIVE_TOPOLOGY d3dPrim[] = {
	D3D_PRIMITIVE_TOPOLOGY_POINTLIST,
	D3D_PRIMITIVE_TOPOLOGY_LINELIST,
	D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,
	D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
	D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
	D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,
	D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,
	D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,
	D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,
	D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST,
	D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST,
};
const D3D11_FILTER Filters[ANISOTROPIC+1] = { D3D11_FILTER_MIN_MAG_MIP_POINT, D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT, D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT, D3D11_FILTER_MIN_MAG_MIP_LINEAR, D3D11_FILTER_ANISOTROPIC};
const D3D11_TEXTURE_ADDRESS_MODE AddressModes[BORDER+1] = {D3D11_TEXTURE_ADDRESS_WRAP, D3D11_TEXTURE_ADDRESS_CLAMP, D3D11_TEXTURE_ADDRESS_BORDER };

extern const DXGI_FORMAT formats[];

#define MAX_RTS 8
#define MAX_VERTEXSTREAM 8
#define MAX_SAMPLERSTATE 8

enum Map_Type {Not_Set=0, Diffuse_Map, Normal_Map, Normal_Bump_Map, MAX_TEXTUREUNIT };
// Texture flags
enum Tex_Flags {NO_TEX_FLAGS=0, CUBEMAP=0x1, HALF_float= 0x2, SRGB =0x4 , SAMPLE_DEPTH = 0x8, SAMPLE_SLICES = 0x10, RENDER_SLICES = 0x20, USE_MIPGEN =0x40};

//COLORS
enum ColorMask { RED=1, GREEN =2, BLUE =4, ALPHA= 8, ALL = (RED | GREEN | BLUE | ALPHA) };

enum FORMAT {
	FORMAT_NONE     = 0,

	// Unsigned formats
	FORMAT_R8       = 1,
	FORMAT_RG8      = 2,
	FORMAT_RGB8     = 3,
	FORMAT_RGBA8    = 4,

	FORMAT_R16      = 5,
	FORMAT_RG16     = 6,
	FORMAT_RGB16    = 7,
	FORMAT_RGBA16   = 8,

	// Signed formats
	FORMAT_R8S      = 9,
	FORMAT_RG8S     = 10,
	FORMAT_RGB8S    = 11,
	FORMAT_RGBA8S   = 12,

	FORMAT_R16S     = 13,
	FORMAT_RG16S    = 14,
	FORMAT_RGB16S   = 15,
	FORMAT_RGBA16S  = 16,

	// Float formats
	FORMAT_R16F     = 17,
	FORMAT_RG16F    = 18,
	FORMAT_RGB16F   = 19,
	FORMAT_RGBA16F  = 20,

	FORMAT_R32F     = 21,
	FORMAT_RG32F    = 22,
	FORMAT_RGB32F   = 23,
	FORMAT_RGBA32F  = 24,

	// Signed integer formats
	FORMAT_R16I     = 25,
	FORMAT_RG16I    = 26,
	FORMAT_RGB16I   = 27,
	FORMAT_RGBA16I  = 28,

	FORMAT_R32I     = 29,
	FORMAT_RG32I    = 30,
	FORMAT_RGB32I   = 31,
	FORMAT_RGBA32I  = 32,

	// Unsigned integer formats
	FORMAT_R16UI    = 33,
	FORMAT_RG16UI   = 34,
	FORMAT_RGB16UI  = 35,
	FORMAT_RGBA16UI = 36,

	FORMAT_R32UI    = 37,
	FORMAT_RG32UI   = 38,
	FORMAT_RGB32UI  = 39,
	FORMAT_RGBA32UI = 40,

	// Packed formats
	FORMAT_RGBE8    = 41,
	FORMAT_RGB9E5   = 42,
	FORMAT_RG11B10F = 43,
	FORMAT_RGB565   = 44,
	FORMAT_RGBA4    = 45,
	FORMAT_RGB10A2  = 46,

	// Depth formats
	FORMAT_D16      = 47,
	FORMAT_D24      = 48,
	FORMAT_D24S8    = 49,
	FORMAT_D32F     = 50,

	// Compressed formats
	FORMAT_DXT1     = 51,
	FORMAT_DXT2     = 52,
	FORMAT_DXT3     = 53,
	FORMAT_DXT4    = 54,
	FORMAT_DXT5    = 55,

	FORMAT_RG32TL   = 56,
}; 

extern const float FormatStride[FORMAT_RG32TL +1];
extern const float DXGI_FormatStride[];

class FormatDesc {
public:
	unsigned int Stream;
	AttributeType Type;
	AttributeFormat Format;
	unsigned int Size;
	bool Instance;
	FormatDesc( AttributeType type = TYPE_VERTEX, AttributeFormat format = FORMAT_FLOAT, unsigned int size = 3, unsigned int stream = 0, bool instance = false ): Stream(stream), Type(type), Format(format), Size(size), Instance(instance) {}
};

class FormatDesc_SO {
public:
  unsigned int   Stream;
  const char* SemanticName;
  unsigned int   SemanticIndex;
  unsigned char   StartComponent;
  unsigned char   ComponentCount;
  unsigned char   OutputSlot;
  FormatDesc_SO(unsigned int stream, const char* semanticname, unsigned int semanticindex, unsigned char startcomponent, unsigned char componentcount, unsigned char outputslot):Stream(stream), SemanticName(semanticname), SemanticIndex(semanticindex), StartComponent(startcomponent), ComponentCount(componentcount), OutputSlot(outputslot) {}
  FormatDesc_SO(): Stream(0), SemanticName("Position"), SemanticIndex(0), StartComponent(0), ComponentCount(3), OutputSlot(0) {}
};
namespace Vertex_Types{
	class Position{
	public:
		vec3 Pos;
	};
	class TexCoord{
	public:
		vec2 Tex;
	};
	class Normal{
	public:
		vec3 Norm;
	};
	class Tangent{
	public:
		vec3 Tang;
	};
	class Bone_Weight{// you cant have bones without weights..
	public:
		unsigned char Bones[4];// bone index.. no need to use a float here.
		vec4 Weights;
	};
	class Pos_Tex: public Position, public TexCoord{ };
	class Tex_Norm: public TexCoord, public Normal{ };
	class Pos_Tex_Norm: public Position, public TexCoord, public Normal{ };
	class Pos_Tex_Norm_Tang: public Position, public TexCoord, public Normal, public Tangent{ };
};

#endif 